## 此篇为二分搜索的总结，接下来先给出二分的两个模板

```c++
	  while(l<r){
	  	int mid = l+r>>1;
	  	if(a[mid] >=x) r=mid;
	  	else l = mid +1;
	  }
```
### 此模板为在单调递增的序列a中查找>=x的数中最小的一个，即找到符合条件的最小值(左区间)，
```c++
	  while(l<r){
	  	int mid = l+r+1>>1;
	  	if(a[mid] <=x) l=mid;
	  	else r = mid -1;
	  }
```
### 此模板为在单调递增的序列a中查找<=x的数中最大的一个，即找到符合条件的最大值(右区间)

## 值得一提的是，在以上两个模板以及接下来给定的二分答案模板中，l 和 r的取值范围是要考虑一下的。因为这两个模板都覆盖[l,r]的全部情况，所以如果要处理无解的情况的话，则需要把第一个模板的[1,n]扩大到[1,n+1]，把第二个模板的[1,n]扩大到[0,n]。原因在于 mid = l+r>>1不会去到r值, mid = l+r+1>>1不会去到l值。如果最后判断等于那个越界的数，则代表无解,下面是相关例题

### p4343自动刷题机[link](https://www.luogu.com.cn/problem/P4343)

### 二分答案的模板
```c++
	  while(l<r){
	  	int mid = l+r+1>>1;
	  	if(calc(mid)) l=mid;
	  	else r = mid -1;
	  }
```
```c++
	  while(l<r){
	  	int mid = l+r>>1;
	  	if(calc(mid)) r=mid;
	  	else l = mid +1;
	  }
```

### 第一个找右区间，第二个找左区间，正确写出二分的流程为：
- 通过分析具体问题，确定左右半段哪一个是可行区间，以及mid归属那一半
- 根据分析结果选择以上两个模板
- 最后 l==r就是答案所在
- 需要注意的是，对于calc函数的设计，一定要想明白他的意义，否则很容易产生错误

### 实数域上的二分模板
```c++
	  while(l + 1e5<r){
	  	double mid = l+r>>1;
	  	if(calc(mid)) r=mid;
	  	else l = mid;
	  }
```

### 三分法请具体到oi wiki了解